## FPGA UDP AD采样数据上位机软件开发文档

本文档旨在为开发基于Python和PyQt5的FPGA UDP AD采样数据上位机软件提供详细指南。该软件将高效接收FPGA通过千兆以太网发送的AD采样数据，并在用户界面上实时显示波形并保存数据。

### 1. UDP协议的具体实现细节

#### 1.1 数据包格式

为了确保数据的正确解析，FPGA发送的AD采样数据包和上位机接收的数据包需要遵循预定义的数据格式。以下是一个示例数据包格式，实际应用中可根据FPGA输出数据特性进行调整。

| 字段          | 长度 (字节) | 类型       | 描述                                     |
| :------------ | :---------- | :--------- | :--------------------------------------- |
| **起始标志** | 2           | `0xAA 0x55` | 固定值，用于识别数据包的起始             |
| **数据长度** | 2           | `int`      | 紧随其后的有效AD采样数据长度（不包含CRC和终止标志） |
| **数据类型** | 1           | `0x01`     | 固定为 `0x01`，表示AD采样数据            |
| **帧计数** | 4           | `int`      | FPGA内部帧计数，用于检查数据连续性       |
| **有效载荷** | 可变        | `int16[]`  | **AD采样值数组，每个采样值16位有符号整数** |
| **CRC校验** | 2           | `int`      | CRC-16校验码，用于数据完整性校验         |
| **终止标志** | 2           | `0x55 0xAA` | 固定值，用于识别数据包的结束             |

**说明:**

* **字节序 (Endianness):** 务必明确FPGA和上位机之间的数据字节序（**大端或小端**），并保持一致。**推荐使用网络字节序（大端）**。
* **有效载荷:** FPGA发送的AD采样数据应打包成16位有符号整数数组，例如：`[sample1, sample2, ..., samplen]`。

#### 1.2 传输机制

* **UDP服务器:** 上位机软件将作为UDP服务器，监听FPGA发送数据的特定IP地址和端口。
* **IP地址和端口:**
    * **上位机IP地址:** 配置一个固定的IP地址，例如 `192.168.1.100`。
    * **监听端口:** 选择一个未被占用的端口，例如 `12345`。
    * **FPGA目标IP地址和端口:** FPGA需要配置为将数据发送到上位机的IP地址和监听端口。
* **数据流:** FPGA持续地以预定义的数据包格式向上位机发送UDP数据报。上位机监听并接收这些数据报。
* **异步接收:** 为了不阻塞UI，**数据接收务必在独立的线程中进行**。

---
### 2. PyQt5界面设计和功能说明

上位机界面应简洁直观，方便用户操作和监控数据。

#### 2.1 界面布局 (示例)

```
+-----------------------------------------------------------------------+
| FPGA AD采样数据接收上位机                                             |
+-----------------------------------------------------------------------+
| [配置区域]                                                            |
|   IP地址: [文本框]  端口: [文本框]                                    |
|   [开始接收] [停止接收] [保存数据]                                   |
|   文件路径: [文本框] [选择路径]                                      |
|-----------------------------------------------------------------------|
| [波形显示区域]                                                        |
|   <Matplotlib 波形图> (实时显示AD采样数据波形)                        |
|-----------------------------------------------------------------------|
| [状态信息/日志]                                                       |
|   当前帧计数: [标签]                                                  |
|   接收速率: [标签] (例如：Mbps)                                       |
|   丢包率: [标签] (%)                                                  |
|   [文本浏览器] (显示连接状态、错误信息、警告等)                         |
+-----------------------------------------------------------------------+
```

#### 2.2 控件作用和交互逻辑

1.  **配置区域:**
    * **IP地址文本框 (QLineEdit):** 用于输入上位机监听的IP地址。
    * **端口文本框 (QLineEdit):** 用于输入上位机监听的端口号。
    * **开始接收按钮 (QPushButton):**
        * 点击后，创建并启动UDP接收线程和数据处理线程。
        * 禁用自身和IP/端口文本框，启用“停止接收”按钮。
        * 更新状态信息，显示“正在监听…”
    * **停止接收按钮 (QPushButton):**
        * 点击后，停止UDP接收和数据处理线程。
        * 启用IP/端口文本框和“开始接收”按钮，禁用自身。
        * 更新状态信息，显示“停止监听”。
    * **保存数据按钮 (QPushButton):**
        * 点击后，将当前接收并缓存的AD采样数据保存到文件中。文件名可以自动按时间戳生成或由用户输入。
    * **文件路径文本框 (QLineEdit):** 显示数据保存的默认路径。
    * **选择路径按钮 (QPushButton):** 弹出文件夹选择对话框，允许用户选择数据保存路径。

2.  **波形显示区域 (Matplotlib Canvas):**
    * 嵌入PyQt5界面的 **Matplotlib图表**，用于实时显示AD采样数据的波形。
    * **交互逻辑:** 接收到新数据后，异步更新图表内容。需要支持**缩放、平移**等基本图表操作，以便用户查看细节。
    * **高效绘图:** 考虑到数据量大，需要采用 **Matplotlib的`blit`技术或PyQtGraph** 等高性能绘图库进行优化，避免每次全图重绘，提高实时性。

3.  **状态信息/日志区域:**
    * **当前帧计数标签 (QLabel):** 显示最新接收到的数据包的帧计数。
    * **接收速率标签 (QLabel):** 显示当前实时的UDP数据接收速率（例如：Mbps），用于性能监控。
    * **丢包率标签 (QLabel):** 显示计算出的丢包率，用于评估数据传输的完整性。
    * **文本浏览器 (QTextBrowser):**
        * 显示应用程序的运行状态（如“初始化完成”、“正在接收数据”、“连接错误”）。
        * 记录CRC校验结果、解析错误等日志信息。
        * 可以添加滚动条，便于查看历史日志。

---
### 3. 数据接收和处理算法

考虑到256Mbps的数据速率，高效的数据接收和处理至关重要。

#### 3.1 高效UDP数据接收

1.  **独立线程:**
    * **必须使用单独的线程（或进程）** 来执行 `socket.recvfrom()` 操作，避免阻塞主UI线程。
    * 主线程负责UI更新，工作线程负责数据接收和初步解析。

2.  **UDP Socket 配置:**
    * **增大接收缓冲区:** 这是提高UDP接收效率最重要的一步。默认的UDP接收缓冲区可能不足以应对256Mbps的数据流，容易导致丢包。
        ```python
        import socket
        # ...
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        # 设置更大的接收缓冲区，例如 16MB (根据系统限制和实际测试调整)
        # 注意：不同操作系统对缓冲区大小有限制，需要测试最佳值
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 16 * 1024 * 1024)
        sock.bind((self.ip, self.port))
        ```
    * **非阻塞模式 (可选):** 如果不使用超时，可以设置为非阻塞模式，但通常配合 `socket.settimeout()` 更容易管理。

3.  **数据队列:**
    * UDP接收线程将接收到的 **原始字节数据包** 放入一个 **线程安全的队列 (如 `queue.Queue`)**。
    * **生产者-消费者模型:** UDP接收线程是生产者，数据解析和处理线程是消费者。这能解耦接收和处理过程，提高整体吞吐量。

#### 3.2 数据包解析和校验

1.  **独立处理线程:**
    * 创建一个单独的 **数据处理线程**，从上述队列中取出原始数据包进行解析和校验。
    * 这样可以避免数据解析的计算开销影响UDP接收的速率。

2.  **快速解析:**
    * 使用 **`struct` 模块进行二进制数据解析**，它的效率远高于手动字节操作。
    * `struct.unpack('>H', ...)` 用于解析固定的头部字段。
    * 对于AD采样数据（有效载荷），使用 `struct.unpack(f'>{num_samples}h', payload)` 可以一次性解析所有16位有符号整数，避免循环解析，极大地提高效率。

3.  **CRC校验:**
    * 在数据处理线程中对每个数据包进行 **CRC-16校验**。如果CRC校验失败，则标记该数据包为错误，并记录日志，但不阻止后续数据接收。
    * CRC算法需要与FPGA端的实现**完全一致**。

4.  **丢包检测:**
    * 通过 **帧计数** (`frame_count`) 来检测丢包。
    * 在数据处理线程中，记录上一个接收到的帧计数，与当前帧计数进行比较。如果 `当前帧计数 - 上一个帧计数 > 1`，则表示有丢包发生。
    * 计算并实时更新丢包率。

#### 3.3 数据展示与保存

1.  **数据缓存:**
    * 为了实时波形显示和数据保存，需要将解析后的AD采样数据缓存起来。
    * 可以使用 **`collections.deque`** (双端队列) 来存储最近的N个采样点，用于实时波形显示，当队列满时，自动移除最旧的数据。
    * 对于数据保存，可以设置一个累积缓冲区，达到一定大小或点击保存时写入文件。

2.  **UI更新策略:**
    * **信号槽机制:** 解析后的AD采样数据和状态信息（帧计数、接收速率、丢包率）通过PyQt的 `pyqtSignal` 发送到UI主线程的槽函数。
    * **定时器更新:** **不要在每个数据包到达时都更新UI**。这会导致UI卡顿。
        * 设置一个 **`QTimer` (例如，每 50-100ms 触发一次)**。
        * 当定时器触发时，UI线程从数据缓存中取出最新的N个采样点更新波形图，并更新状态标签。
        * 这样可以平滑UI更新，减少CPU占用。

3.  **波形显示优化:**
    * **Matplotlib `blit`:** 使用 `blit=True` 参数进行动画更新，只重绘变化的部分，而不是整个画布。
    * **PyQtGraph:** 对于高性能的实时曲线绘制，PyQtGraph是比Matplotlib更好的选择，它专为科学数据和实时显示优化。

4.  **数据保存:**
    * 将接收到的AD采样数据保存为文件（例如 `.csv`, `.txt` 或 `.bin`）。
    * 对于文本格式，可以每行保存一个或多个采样值，并包含时间戳和帧计数等元数据。
    * 对于大数据量，**二进制格式 (`.bin`)** 更高效，可以直接将原始或解析后的整数数组写入文件。

---
### 4. 错误处理和异常管理策略

健全的错误处理机制是软件稳定性的关键。

1.  **UDP Socket错误:**
    * **绑定失败:** 端口被占用、IP地址无效。捕获 `socket.error` 异常，向用户显示清晰的错误信息到日志区域。
    * **网络断开:** 接收数据时网络连接中断。捕获相关异常，并在日志中提示，软件可尝试重新绑定或提示用户检查网络。
    * **发送/接收超时:** 如果设置了超时，捕获 `socket.timeout`，表示在指定时间内未收到数据。

2.  **数据解析错误:**
    * **数据包不完整/长度不符:** 检查接收到的数据长度是否满足最小数据包长度，并与数据包中声明的长度进行比对。
    * **标志位错误:** 起始标志和终止标志不匹配。
    * **CRC校验失败:** 记录错误日志，并在UI上提示数据完整性受损，可以选择丢弃该数据包或显示警告波形。
    * **结构解析异常:** `struct.unpack` 可能因数据格式不匹配而抛出异常。
    * **处理策略:** 记录详细的错误日志，包括原始数据包的十六进制表示，方便排查FPGA端问题。错误数据包可以被丢弃，但不应导致软件崩溃。

3.  **UI交互错误:**
    * **输入校验:** 对用户输入的IP地址和端口号进行合法性校验（例如，是否是有效IP格式，端口是否在合法范围内）。
    * **资源释放:** 确保在应用程序关闭时正确关闭UDP socket和停止所有线程。使用 `try...finally` 或 `with` 语句确保资源被释放。

4.  **日志记录:**
    * 使用Python的 **`logging` 模块** 记录各种级别的日志（DEBUG, INFO, WARNING, ERROR, CRITICAL）。
    * 将日志输出到文件和UI界面的状态/日志区域，便于调试和用户查看。
    * 对于高速数据流，日志记录本身也会有性能开销，需要平衡日志的详细程度和性能。

---
### 5. 性能优化建议

针对256Mbps的数据速率，以下是关键的性能优化建议：

1.  **多线程/多进程模型:**
    * **UDP接收线程:** 专门负责从网卡接收原始UDP数据包，并尽可能快地放入队列。
    * **数据处理线程:** 从队列中取出数据包，进行解析、校验和丢包检测。
    * **UI更新线程 (主线程):** 从数据处理线程的数据缓存中获取数据进行波形绘制和状态更新。
    * 对于极高的处理负载，甚至可以考虑 **多进程**（使用 `multiprocessing` 模块）来利用多核CPU并行处理。

2.  **零拷贝 (Zero-Copy) / 最小化拷贝:**
    * 在Python中实现真正的零拷贝比较困难，但要尽量减少数据拷贝。
    * `socket.recvfrom()` 返回的是 `bytes` 对象。直接对这个 `bytes` 对象进行 `struct.unpack` 操作，避免先转换为列表或其他中间结构。
    * 如果数据需要传递给NumPy，尽量使用 `np.frombuffer()` 从字节缓冲区创建数组，而不是先解包成Python列表再转换。

3.  **NumPy/SciPy 高效运算:**
    * **数据解析:** 将AD采样值解析为NumPy数组 (`np.frombuffer(payload, dtype=np.int16)`)，后续的数据处理（如波形绘制、统计分析）都基于NumPy数组进行，充分利用其C语言优化的底层实现。
    * **数据处理:** 任何需要对大量采样点进行的计算（如求均值、峰值、滤波等）都应使用NumPy函数。

4.  **高效波形绘图库:**
    * **PyQtGraph:** **强烈推荐使用PyQtGraph**，它比Matplotlib在实时绘图方面性能更优，尤其适用于处理大量数据点的动态曲线。它支持GPU加速（如果系统支持）。
    * **Matplotlib `blit` 模式:** 如果坚持使用Matplotlib，务必启用 `blit=True` 进行动画更新，只重绘变化的部分。

5.  **数据缓冲管理:**
    * **`collections.deque`:** 对于实时波形显示，使用 `deque` 作为环形缓冲区，存储固定数量的最新数据点。
    * **文件写入优化:**
        * 不要每收到一个数据包就立即写入文件。
        * **缓存写入:** 将接收到的数据累积到内存缓冲区中，当缓冲区达到一定大小（例如 1MB 或 10MB）时，一次性写入文件。
        * **异步写入:** 可以创建一个专门的 **文件写入线程**，从一个单独的队列中获取要保存的数据，然后写入磁盘，避免阻塞主数据流。
        * 使用 `rb` 或 `wb` 模式以二进制方式写入数据，而非文本模式，可以提高写入速度和减少存储空间。

6.  **GC优化 (垃圾回收):**
    * 避免在高速循环中创建大量临时对象，减少垃圾回收的频率和开销。
    * **重用对象:** 如果可能，重用缓冲区或对象，而不是每次都重新分配。

---
### 6. 测试计划和测试用例

#### 6.1 测试计划

1.  **单元测试:** 对独立的模块进行测试，如UDP接收模块、数据解析函数、CRC校验函数。
2.  **集成测试:** 测试各个模块之间的交互，例如UDP接收线程与数据处理线程、数据处理线程与UI更新的集成。
3.  **系统测试:**
    * **功能测试:** 验证所有UI功能、数据处理、波形显示和数据保存是否符合需求。
    * **性能测试:** 在 **256Mbps** 的数据速率下（或更高，接近网卡极限），测试软件的接收能力、处理延迟、CPU/内存占用、丢包率。
    * **稳定性测试:** **长时间（数小时到数天）运行测试**，观察软件是否出现崩溃、内存泄漏或数据丢失。
    * **错误恢复测试:** 模拟网络中断、FPGA数据异常（如CRC错误、数据长度错误）等情况，测试软件的错误处理和恢复能力。
4.  **用户验收测试 (UAT):** 由最终用户验证软件是否满足其业务需求。

#### 6.2 测试用例 (示例)

| 测试ID | 测试目的           | 前置条件                      | 测试步骤                                                                                                                                                                                                                             | 预期结果                                                                       |
| :----- | :----------------- | :---------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------- |
| TC-UDP-001 | 正常高速数据接收   | FPGA按预定格式以256Mbps发送数据，上位机IP/端口配置正确 | 1. 启动上位机软件。 2. 输入正确的IP和端口。 3. 点击“开始接收”。 4. 观察波形显示和状态信息（帧计数、接收速率、丢包率）。                                                                                                       | 软件能持续、稳定地接收并解析数据，波形显示流畅，接收速率接近256Mbps，丢包率接近0%。 |
| TC-UDP-002 | 大数据量长时间运行 | 同TC-UDP-001，持续运行4小时以上 | 1. 按照TC-UDP-001步骤运行。 2. 保持软件运行数小时。 3. 周期性检查内存占用和CPU使用率。                                                                                                                                               | 软件能稳定运行，无崩溃、内存泄漏，CPU和内存占用保持稳定且合理。                |
| TC-UDP-003 | CRC校验失败        | FPGA端故意发送CRC错误的数据包（例如，部分数据被篡改） | 1. FPGA端故意发送CRC错误的数据包。 2. 观察状态信息/日志区域。                                                                                                                                                            | 软件日志显示“CRC校验失败”并指示具体数据包信息，波形可能显示异常或跳变，但不影响后续数据接收。 |
| TC-UDP-004 | 丢包检测与显示     | FPGA端模拟丢包（例如，短暂停止发送或降低发送速率再恢复） | 1. 开始正常接收。 2. 模拟FPGA端丢弃部分数据包。 3. 观察丢包率标签和帧计数是否正确反映丢包情况。                                                                                                                         | 丢包率标签能实时更新并显示正确的丢包率，帧计数出现跳变。                       |
| TC-UDP-005 | 数据保存功能       | 已接收大量数据                | 1. 接收大量数据。 2. 点击“保存数据”按钮，选择保存路径。 3. 观察保存进度，打开保存的文件。                                                                                                                             | 数据能正确保存到指定文件，内容完整、格式正确（例如，CSV或二进制），文件大小与接收数据量匹配。 |
| TC-UDP-006 | 波形缩放与平移     | 波形显示中                    | 1. 接收数据并显示波形。 2. 尝试在波形图上进行缩放和平移操作。                                                                                                                                                          | 波形图能流畅响应缩放和平移操作，显示内容随之更新。                             |
| TC-UDP-007 | 停止/启动功能      | 无                            | 1. 启动接收。 2. 停止接收。 3. 再次启动接收。 4. 停止接收，关闭软件。                                                                                                                                              | 软件能正常停止和启动接收，且状态显示正确。关闭软件时，所有线程和资源能正确释放。 |
| TC-UDP-008 | 网络断开恢复       | 接收过程中断开/重新连接网线   | 1. 开始接收数据。 2. 模拟网络断开（拔网线）。 3. 观察软件行为。 4. 重新插上网线。 5. 观察软件行为。                                                                                                                            | 软件应在日志中提示网络断开错误，并在网络恢复后能自动尝试重新连接或提示用户手动重连。 |

---
### 7. 文档结构和编写规范

#### 7.1 文档结构

本开发文档的结构旨在清晰、全面地涵盖软件开发的所有重要方面，便于团队成员理解和维护。

* **1. 引言:** 介绍文档目的、软件主要功能和特性。
* **2. UDP协议实现:** 详细的数据包格式、数据传输流程、IP/端口分配。
* **3. PyQt5界面设计:** 界面布局、核心控件、用户交互逻辑。
* **4. 数据接收和处理模块:**
    * **4.1 高效UDP数据接收:** 线程模型、socket配置、数据队列。
    * **4.2 数据包解析和校验:** 校验机制、错误处理、丢包检测。
    * **4.3 数据展示与保存:** 数据缓存、UI更新策略、波形显示优化、数据保存格式与方法。
* **5. 错误处理和异常管理:** 详细的错误类型、处理策略、日志机制。
* **6. 性能优化建议:** 针对256Mbps数据流的优化策略（多线程、NumPy、PyQtGraph、缓冲区管理等）。
* **7. 测试计划:** 单元测试、集成测试、系统测试的策略和用例。
* **8. 部署指南:** 软件的打包、安装和运行说明（如果需要）。
* **9. 维护和扩展:** 常见问题、未来可能的功能扩展。
* **10. 附录:** 相关参考资料、第三方库说明等。

#### 7.2 编写规范

* **清晰简洁:** 使用清晰、直接的语言，避免模糊不清的表述。
* **专业术语:** 统一使用技术术语，并对其进行适当的解释。
* **结构化:** 使用标题、子标题、列表和表格来组织内容，提高可读性。
* **代码示例:** 在需要说明算法或关键实现时，提供简洁且带有注释的伪代码或关键代码片段，而不是完整的可运行代码。
* **图表辅助:** 使用流程图、界面草图等辅助说明复杂概念。
* **版本控制:** 文档应纳入版本控制系统，每次修改都应记录版本号、修改日期和修改人。
* **及时更新:** 软件功能变更时，及时更新相关文档内容，确保文档与代码同步。
* **审阅机制:** 重要的文档变动需要经过团队内部审阅。
* **Markdown/reStructuredText:** 推荐使用Markdown或reStructuredText编写文档，易于版本控制和生成HTML/PDF等多种格式。
* **一致性:** 保持排版、格式和命名约定的一致性。
